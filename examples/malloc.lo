main |
    heap_open: [any; 1000],
    heap_books: [uint; 100],
    heap_book_vec: [any; 3],
    heap: [any; 2],

    str: val,
    val: &uint,
    arr: &[uint; 3],
    val2: &num,
    five: &[int; 5],
| {
    Vec_new(&heap_book_vec, <<&any>>&heap_books, 100);
    Heap_new(&heap, &heap_open, &heap_book_vec);

    malloc(<<&&any>>&val, &heap, 1);
    *val = 10;
    Vec_to_str(&str, &heap_book_vec);
    out(str);

    malloc(<<&&any>>&arr, &heap, 3);
    *arr = [11, 22, 33];
    Vec_to_str(&str, &heap_book_vec);
    out(str);

    malloc(<<&&any>>&val2, &heap, 1);
    *val2 = -9.5;
    Vec_to_str(&str, &heap_book_vec);
    out(str);

    free(&heap, <<&any>>val);
    Vec_to_str(&str, &heap_book_vec);
    out(str);

    malloc(<<&&any>>&five, &heap, 5);
    *five = [-2, -1, 0, 1, 2];
    Vec_to_str(&str, &heap_book_vec);
    out(str);

    malloc(<<&&any>>&val, &heap, 1);
    *val = 88;
    Vec_to_str(&str, &heap_book_vec);
    out(str);
}

func Heap_new(ret: &[any; 2], open: &[any; 1000], books: &[any; 3]) || {
    *ret = [open, books];
}

func Heap_open(ret: &&[any; 1000], self: &[any; 2]) || {
    *ret = <<&[any; 1000]>>(*self)[0];
}

func Heap_books(ret: &&[any; 3], self: &[any; 2]) || {
    *ret = <<&[any; 3]>>(*self)[1];
}

func Heap_books_find_open(ret: &uint, books: &[any; 3], size: uint)
    |i: uint, len: uint, addr: uint, start: uint, end: uint, range: uint, loop: bool|
{
    i = 0;
    addr = 0;
    loop = true;

    Vec_len(&len, books);

    while (loop && (i < len)) {
        Vec_get(<<&any>>&start, books, i);
        Vec_get(<<&any>>&end, books, (i + 1));
        range = <uint>(end - start);

        if (((addr >= start) && (addr < end)) || (size > range)) {
            addr = end;
            i = (i + 2);
        } else {
            loop = false;
        };
    };

    Vec_insert(books, (addr + size), i);
    Vec_insert(books, addr, i);

    *ret = addr;
}

func malloc(ret: &&any, heap: &[any; 2], size: uint)
    |addr: uint, books: &[any; 3], open: &[any; 1000]|
{
    Heap_open(&open, heap);
    Heap_books(&books, heap);
    Heap_books_find_open(&addr, books, size);
    *ret = <<&any>>&(*open)[addr];
}

func free(heap: &[any; 2], ptr: &any)
    |open: &[any; 1000], addr: uint, books: &[any; 3], len: uint, i: uint, start: uint, null: any|
{
    Heap_open(&open, heap);
    Heap_books(&books, heap);
    Vec_len(&len, books);

    addr = <uint>(<uint>ptr - <uint>open);
    i = 0;
    while (i < len) {
        Vec_get(<<&any>>&start, books, i);
        if (start == addr) {
            Vec_remove(&null, books, i);
            Vec_remove(&null, books, i);
            i = len;
        } else {
            i = (i + 2);
        };
    };
}

func Vec_new(ret: &[any; 3], arr: &any, cap: uint) || {
    *ret = [arr, cap, 0];
}

func Vec_arr(ret: &&any, self: &[any; 3]) || {
    *ret = <<&any>>(*self)[0];
}

func Vec_cap(ret: &uint, self: &[any; 3]) || {
    *ret = <uint>((*self)[1]);
}

func Vec_len_mut(ret: &&uint, self: &[any; 3]) || {
    *ret = <<&uint>>&((*self)[2]);
}

func Vec_len(ret: &uint, self: &[any; 3]) || {
    *ret = <uint>((*self)[2]);
}

func Vec_get_mut(ret: &&any, self: &[any; 3], i: uint) |arr: &any| {
    Vec_arr(&arr, self);
    *ret = <<&any>>(<uint>arr + i);
}

func Vec_get(ret: &any, self: &[any; 3], i: uint) |entry: &any| {
    Vec_get_mut(&entry, self, i);
    *ret = *entry;
}

func Vec_push(self: &[any; 3], val: any) |len: &uint, entry: &any| {
    Vec_len_mut(&len, self);
    Vec_get_mut(&entry, self, *len);
    *entry = val;
    *len = (*len + 1);
}

func Vec_pop(ret: &any, self: &[any; 3]) |len: &uint, val: any| {
    Vec_len_mut(&len, self);
    Vec_get(&val, self, <uint>(*len - 1));
    *ret = val;
    *len = <uint>(*len - 1);
}

func Vec_insert(self: &[any; 3], val: any, index: uint)
    |i: uint, len: uint, entry: &any, next_entry: &any|
{
    Vec_len(&len, self);
    i = len;
    Vec_push(self, 0);

    while (i >= index) {
        Vec_get_mut(&entry, self, i);
        Vec_get_mut(&next_entry, self, (i + 1));
        *next_entry = *entry;

        i = <uint>(i - 1);
    };

    Vec_get_mut(&entry, self, index);
    *entry = val;
}

func Vec_remove(ret: &any, self: &[any; 3], index: uint)
    |i: uint, entry: &any, next_entry: &any, len: &uint|
{
    Vec_get(ret, self, index);
    i = index;
    Vec_len_mut(&len, self);
    *len = <uint>(*len - 1);

    while (i < *len) {
        Vec_get_mut(&entry, self, i);
        Vec_get_mut(&next_entry, self, (i + 1));
        *entry = *next_entry;

        i = (i + 1);
    };
}

func Vec_to_str(ret: &val, self: &[any; 3]) |str: val, len: uint, i: uint, val: val| {
    str = "[";
    Vec_len(&len, self);
    i = 0;

    while (i < len) {
        Vec_get(<<&any>>&val, self, i);
        str = (str ~ val);
        if (i != (len - 1)) {
            str = (str ~ ", ");
        };

        i = (i + 1);
    };

    str = (str ~ "]");
    *ret = str;
}
