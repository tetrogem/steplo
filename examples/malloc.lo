main {
    let heap: Heap = Heap_new();

    let val: &uint = <<&uint>>malloc(&heap, 1);
    *val = 10;
    Heap_report_books(&heap);

    let arr: &[uint; 3] = <<&[uint; 3]>>malloc(&heap, 3);
    *arr = [11, 22, 33];
    Heap_report_books(&heap);

    let val2: &num = <<&num>>malloc(&heap, 1);
    *val2 = -9.5;
    Heap_report_books(&heap);

    free(&heap, <<&any>>val);
    Heap_report_books(&heap);

    let five: &[int; 5] = <<&[int; 5]>>malloc(&heap, 5);
    *five = [-2, -1, 0, 1, 2];
    Heap_report_books(&heap);

    val = <<&uint>>malloc(&heap, 1);
    *val = 88;
    Heap_report_books(&heap);
}

type Heap = {
    open: [any; 1000],
    books_mem: [uint; 100],
    cap: uint,
    len: uint,
};

fn Heap_new() -> Heap { open: undefined, books_mem: undefined, cap: 1000, len: 0 }

fn Heap_books_find_open(self: &Heap, size: uint) -> uint {
    let i: uint = 0;
    let addr: uint = 0;
    let loop: bool = true;
    let books: _Vec = Heap_books_vec(self);

    while (loop && (i < *books.len)) {
        let start: uint = <<uint>>_Vec_get(&books, i);
        let end: uint = <<uint>>_Vec_get(&books, (i + 1));
        let range: uint = <<uint>>(end - start);

        if (((addr >= start) && (addr < end)) || (size > range)) {
            addr = end;
            i = (i + 2);
        } else {
            loop = false;
        }
    }

    _Vec_insert(&books, (addr + size), i);
    _Vec_insert(&books, addr, i);

    addr
}

fn Heap_books_vec(self: &Heap) -> _Vec {
    arr: <<&any>>&(*self).books_mem,
    cap: &(*self).cap,
    len: &(*self).len,
}

fn Heap_report_books(self: &Heap) {
    let books: _Vec = Heap_books_vec(self);
    out(_Vec_to_str(&books));
}

fn malloc(heap: &Heap, size: uint) -> &any {
    let addr: uint = Heap_books_find_open(heap, size);
    <<&any>>&(*heap).open[addr]
}

fn free(heap: &Heap, ptr: &any) {
    let addr: uint = <<uint>>(<uint>ptr - <uint>&(*heap).open);
    let i: uint = 0;
    let books: _Vec = Heap_books_vec(heap);

    while (i < *books.len) {
        let start: uint = <<uint>>_Vec_get(&books, i);

        if (start == addr) {
            _Vec_remove(&books, i);
            _Vec_remove(&books, i);
            i = *books.len;
        } else {
            i = (i + 2);
        }
    }
}

// The underscore signifies _Vec is an "unsafe" struct
// it can't be moved without invalidating its references, so it needs to be used carefully
// (should never be moved up out of the scope it was created in)
type _Vec = {
    arr: &any,
    cap: &uint,
    len: &uint,
};

fn _Vec_get_mut(self: &_Vec, i: uint) -> &any <<&any>>(<uint>(*self).arr + i)
fn _Vec_get(self: &_Vec, i: uint) -> any *_Vec_get_mut(self, i)

fn _Vec_push(self: &_Vec, val: any) {
    let entry: &any = _Vec_get_mut(self, *(*self).len);
    *entry = val;
    *(*self).len = (*(*self).len + 1);
}

fn _Vec_pop(self: &_Vec) -> any {
    let val: any = _Vec_get(self, <<uint>>(*(*self).len - 1));
    *(*self).len = <<uint>>(*(*self).len - 1);
    val
}

fn _Vec_insert(self: &_Vec, val: any, index: uint) {
    let i: uint = *(*self).len;
    _Vec_push(self, 0);

    let entry: &any = undefined;
    while (i >= index) {
        entry = _Vec_get_mut(self, i);
        let next_entry: &any = _Vec_get_mut(self, (i + 1));
        *next_entry = *entry;

        i = <<uint>>(i - 1);
    }

    entry = _Vec_get_mut(self, index);
    *entry = val;
}

fn _Vec_remove(self: &_Vec, index: uint) -> any {
    let ret: any = _Vec_get(self, index);
    let i: uint = index;
    *(*self).len = <<uint>>(*(*self).len - 1);

    while (i < *(*self).len) {
        let entry: &any = _Vec_get_mut(self, i);
        let next_entry: &any = _Vec_get_mut(self, (i + 1));
        *entry = *next_entry;

        i = (i + 1);
    }

    ret
}

fn _Vec_clear(self: &_Vec) {
    *(*self).len = 0;
}

fn _Vec_to_str(self: &_Vec) -> str {
    let str: str = "[";
    let i: uint = 0;

    while (i < *(*self).len) {
        let val: val = <<val>>_Vec_get(self, i);
        str = (str ~ val);
        if (i != (*(*self).len - 1)) {
            str = (str ~ ", ");
        }

        i = (i + 1);
    }

    str = (str ~ "]");
    str
}

// Expected stdout:
// [0, 1]
// [0, 1, 1, 4]
// [0, 1, 1, 4, 4, 5]
// [1, 4, 4, 5]
// [1, 4, 4, 5, 5, 10]
// [0, 1, 1, 4, 4, 5, 5, 10]
