main {
    let heap_books: [uint; 100] = undefined;
    let heap_book_vec: Vec = undefined;
    Vec_new(&heap_book_vec, <<&any>>&heap_books, 100);

    let heap_open: [any; 1000] = undefined;
    let heap: Heap = undefined;
    Heap_new(&heap, &heap_open, &heap_book_vec);

    let val: &uint = undefined;
    malloc(<<&&any>>&val, &heap, 1);
    *val = 10;

    let str: str = "";
    Vec_to_str(&str, &heap_book_vec);
    out(str);

    let arr: &[uint; 3] = undefined;
    malloc(<<&&any>>&arr, &heap, 3);
    *arr = [11, 22, 33];
    Vec_to_str(&str, &heap_book_vec);
    out(str);

    let val2: &num = undefined;
    malloc(<<&&any>>&val2, &heap, 1);
    *val2 = -9.5;
    Vec_to_str(&str, &heap_book_vec);
    out(str);

    free(&heap, <<&any>>val);
    Vec_to_str(&str, &heap_book_vec);
    out(str);

    let five: &[int; 5] = undefined;
    malloc(<<&&any>>&five, &heap, 5);
    *five = [-2, -1, 0, 1, 2];
    Vec_to_str(&str, &heap_book_vec);
    out(str);

    malloc(<<&&any>>&val, &heap, 1);
    *val = 88;
    Vec_to_str(&str, &heap_book_vec);
    out(str);
}

type Heap = {
    open: &[any; 1000],
    books: &Vec,
};

func Heap_new(ret: &Heap, open: &[any; 1000], books: &Vec) {
    *ret = { open: open, books: books };
}

func Heap_books_find_open(ret: &uint, books: &Vec, size: uint) {
    let i: uint = 0;
    let addr: uint = 0;
    let loop: bool = true;

    while (loop && (i < (*books).len)) {
        let start: uint = 0;
        Vec_get(<<&any>>&start, books, i);

        let end: uint = 0;
        Vec_get(<<&any>>&end, books, (i + 1));

        let range: uint = <<uint>>(end - start);

        if (((addr >= start) && (addr < end)) || (size > range)) {
            addr = end;
            i = (i + 2);
        } else {
            loop = false;
        }
    }

    Vec_insert(books, (addr + size), i);
    Vec_insert(books, addr, i);

    *ret = addr;
}

func malloc(ret: &&any, heap: &Heap, size: uint) {
    let addr: uint = 0;
    Heap_books_find_open(&addr, (*heap).books, size);
    *ret = <<&any>>&(*(*heap).open)[addr];
}

func free(heap: &Heap, ptr: &any) {
    let addr: uint = <<uint>>(<uint>ptr - <uint>(*heap).open);
    let i: uint = 0;
    while (i < (*(*heap).books).len) {
        let start: uint = 0;
        Vec_get(<<&any>>&start, (*heap).books, i);

        if (start == addr) {
            let null: any = 0;
            Vec_remove(&null, (*heap).books, i);
            Vec_remove(&null, (*heap).books, i);
            i = (*(*heap).books).len;
        } else {
            i = (i + 2);
        }
    }
}
type Vec = {
    arr: &any,
    cap: uint,
    len: uint,
};

func Vec_new(ret: &Vec, arr: &any, cap: uint) {
    *ret = { arr: arr, cap: cap, len: 0 };
}

func Vec_get_mut(ret: &&any, self: &Vec, i: uint) {
    *ret = <<&any>>(<uint>(*self).arr + i);
}

func Vec_get(ret: &any, self: &Vec, i: uint) {
    let entry: &any = undefined;
    Vec_get_mut(&entry, self, i);
    *ret = *entry;
}

func Vec_push(self: &Vec, val: any) {
    let entry: &any = undefined;
    Vec_get_mut(&entry, self, (*self).len);
    *entry = val;
    (*self).len = ((*self).len + 1);
}

func Vec_pop(ret: &any, self: &Vec) {
    let val: any = 0;
    Vec_get(&val, self, <<uint>>((*self).len - 1));
    *ret = val;
    (*self).len = <<uint>>((*self).len - 1);
}

func Vec_insert(self: &Vec, val: any, index: uint) {
    let i: uint = (*self).len;
    Vec_push(self, 0);

    let entry: &any = undefined;
    while (i >= index) {
        Vec_get_mut(&entry, self, i);

        let next_entry: &any = undefined;
        Vec_get_mut(&next_entry, self, (i + 1));
        *next_entry = *entry;

        i = <<uint>>(i - 1);
    }

    Vec_get_mut(&entry, self, index);
    *entry = val;
}

func Vec_remove(ret: &any, self: &Vec, index: uint) {
    Vec_get(ret, self, index);
    let i: uint = index;
    (*self).len = <<uint>>((*self).len - 1);

    while (i < (*self).len) {
        let entry: &any = undefined;
        Vec_get_mut(&entry, self, i);

        let next_entry: &any = undefined;
        Vec_get_mut(&next_entry, self, (i + 1));
        *entry = *next_entry;

        i = (i + 1);
    }
}

func Vec_clear(self: &Vec) {
    (*self).len = 0;
}

func Vec_to_str(ret: &str, self: &Vec) {
    let str: str = "[";
    let i: uint = 0;

    while (i < (*self).len) {
        let val: val = 0;
        Vec_get(<<&any>>&val, self, i);
        str = (str ~ val);
        if (i != ((*self).len - 1)) {
            str = (str ~ ", ");
        }

        i = (i + 1);
    }

    str = (str ~ "]");
    *ret = str;
}
